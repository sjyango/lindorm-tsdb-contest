/*
* Copyright Alibaba Group Holding Ltd.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

#pragma once

#include "Root.h"
#include "common/slice.h"
#include "common/coding.h"

namespace LindormContest {

// The FALLTHROUGH_INTENDED macro can be used to annotate implicit fall-through
// between switch labels. The real definition should be provided externally.
// This one is a fallback version for unsupported compilers.
#ifndef FALLTHROUGH_INTENDED
#define FALLTHROUGH_INTENDED \
  do {                       \
  } while (0)
#endif

static uint32_t murmur_hash(const char* data, size_t n) {
    // Similar to murmur hash
    const uint32_t m = 0xc6a4a793;
    const uint32_t r = 24;
    const char* limit = data + n;
    uint32_t h = 0xbc9f1d34 ^ (n * m);

    // Pick up four bytes at a time
    while (data + 4 <= limit) {
        uint32_t w = decode_fixed32_le((const uint8_t*)data);
        data += 4;
        h += w;
        h *= m;
        h ^= (h >> 16);
    }

    // Pick up remaining bytes
    switch (limit - data) {
    case 3:
        h += static_cast<uint8_t>(data[2]) << 16;
        FALLTHROUGH_INTENDED;
    case 2:
        h += static_cast<uint8_t>(data[1]) << 8;
        FALLTHROUGH_INTENDED;
    case 1:
        h += static_cast<uint8_t>(data[0]);
        h *= m;
        h ^= (h >> r);
        break;
    }
    return h;
}

static uint32_t bloom_hash(const Slice& key) {
    return murmur_hash(key.data(), key.size());
}

class BloomFilter {
public:
    explicit BloomFilter(int bits_per_key) : _bits_per_key(bits_per_key) {
        // We intentionally round down to reduce probing cost a little bit
        // k = (m / n) * ln(2), bits_per_key = m / n
        _k = static_cast<size_t>(bits_per_key * 0.69);  // 0.69 =~ ln(2)
        if (_k < 1) {
            _k = 1;
        }
        if (_k > 30) {
            _k = 30;
        }
    }

    void create_filter(const Slice* keys, int n, std::string* dst) const {
        // Compute bloom filter size (in both bits and bytes)
        size_t bits = n * _bits_per_key;

        // For small n, we can see a very high false positive rate.  Fix it
        // by enforcing a minimum bloom filter length.
        if (bits < 64) {
            bits = 64;
        }

        size_t bytes = (bits + 7) / 8;
        bits = bytes * 8;

        const size_t init_size = dst->size();
        dst->resize(init_size + bytes, 0);
        dst->push_back(static_cast<char>(_k));  // Remember # of probes in filter
        char* array = &(*dst)[init_size];

        for (int i = 0; i < n; i++) {
            // Use double-hashing to generate a sequence of hash values.
            // See analysis in [Kirsch,Mitzenmacher 2006].
            uint32_t h = bloom_hash(keys[i]);
            const uint32_t delta = (h >> 17) | (h << 15);  // Rotate right 17 bits

            for (size_t j = 0; j < _k; j++) {
                const uint32_t bit_pos = h % bits;
                array[bit_pos / 8] |= (1 << (bit_pos % 8));
                h += delta;
            }
        }
    }

    bool key_may_match(const Slice& key, const Slice& bloom_filter) const {
        const size_t len = bloom_filter.size();
        if (len < 2) {
            return false;
        }

        const char* array = bloom_filter.data();
        const size_t bits = (len - 1) * 8;

        // Use the encoded k so that we can read filters generated by
        // bloom filters created using different parameters.
        const size_t k = array[len - 1];
        if (k > 30) {
            // Reserved for potentially new encodings for short bloom filters.
            // Consider it a match.
            return true;
        }

        uint32_t h = bloom_hash(key);
        const uint32_t delta = (h >> 17) | (h << 15);  // Rotate right 17 bits
        
        for (size_t j = 0; j < k; j++) {
            const uint32_t bit_pos = h % bits;
            if ((array[bit_pos / 8] & (1 << (bit_pos % 8))) == 0) {
                return false;
            }
            h += delta;
        }
        
        return true;
    }

private:
    size_t _bits_per_key; // => m / n, m为bit数组的大小，n为元素总个数
    size_t _k;            // k为hash函数的个数
};

}